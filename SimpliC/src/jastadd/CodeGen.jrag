/**
 * @author jesper.oqvist@cs.lth.se
 */
aspect CodeGen {

	public void Program.genCode(PrintStream out) {
		out.println(".global _start");
		out.println(".data");
		out.println("ask_message: .ascii \"Please enter a number: \"");
		out.println("ask_msg_len: .quad 23");
		out.println("buf: .skip 1024");
		out.println();
		out.println(".text");

		// allocate space for local variables (bindings):
		// out.println("        pushq %rbp");
		// out.println("        movq %rsp, %rbp");
		// out.println("        subq $" + (getExpr().numLocals()*8) + ", %rsp");

		// getExpr().genEval(out);// stores result in RAX

		for (int i = 0; i < getNumFunc(); ++i) {
			getFunc(i).genEval(out);
		}

		out.println("_start:");
		// print result:
		out.println("        call main");

		// de-allocate local variables:
		// out.println("        movq %rbp, %rsp");
		// out.println("        popq %rbp");

		// call sys_exit:
		out.println("        movq %rax, %rdi");
		out.println("        movq $60, %rax");
		out.println("        syscall"); // done!

		// helper functions
		out.println("# Procedure to read number from stdin");
		out.println("# C signature: long int read(void)");
		out.println("read:");
		out.println("        pushq %rbp");
		out.println("        movq %rsp, %rbp");
		out.println("        movq $0, %rdi");
		out.println("        movq $buf, %rsi");
		out.println("        movq $1024, %rdx");
		out.println("        movq $0, %rax");
		out.println("        syscall                 # %rax = sys_read(0, buf, 1024)");
		out.println("        ### convert string to integer:");
		out.println("        ### %rax contains nchar");
		out.println("        ### %rsi contains ptr");
		out.println("        movq $0, %rdx           # sum = 0");
		out.println("atoi_loop:");
		out.println("        cmpq $0, %rax           # while (nchar > 0)");
		out.println("        jle atoi_done           # leave loop if nchar <= 0");
		out.println("        movzbq (%rsi), %rbx     # move byte, and sign extend to qword");
		out.println("        cmpq $0x30, %rbx        # test if < '0'");
		out.println("        jl atoi_done            # character is not numeric");
		out.println("        cmpq $0x39, %rbx        # test if > '9'");
		out.println("        jg atoi_done            # character is not numeric");
		out.println("        imulq $10, %rdx         # multiply sum by 10");
		out.println("        subq $0x30, %rbx        # value of character");
		out.println("        addq %rbx, %rdx         # add to sum");
		out.println("        incq %rsi               # step to next char");
		out.println("        decq %rax               # nchar--");
		out.println("        jmp atoi_loop           # loop back");
		out.println("atoi_done:");
		out.println("        movq %rdx, %rax         # return value in RAX");
		out.println("        popq %rbp");
		out.println("        ret");
		out.println();
		out.println("# Procedure to print number to stdout");
		out.println("# C signature: void print(long int)");
		out.println("print:");
		out.println("        pushq %rbp");
		out.println("        movq %rsp, %rbp");
		out.println("        ### convert integer to string");
		out.println("        movq 16(%rbp), %rax     # parameter");
		out.println("        movq $(buf+1023), %rsi  # write ptr (start from end of buf)");
		out.println("        movb $0x0a, (%rsi)      # insert newline");
		out.println("        movq $1, %rcx           # string length");
		out.println("itoa_loop:                      # do.. while (at least one iteration)");
		out.println("        movq $10, %rbx");
		out.println("        movq $0, %rdx");
		out.println("        idivq %rbx              # divide rdx:rax by 10");
		out.println("        addb $0x30, %dl         # remainder + '0'");
		out.println("        decq %rsi               # move string pointer");
		out.println("        movb %dl, (%rsi)");
		out.println("        incq %rcx               # increment string length");
		out.println("        cmpq $0, %rax");
		out.println("        jg itoa_loop            # produce more digits");
		out.println("itoa_done:");
		out.println("        movq $1, %rdi");
		out.println("        movq %rcx, %rdx");
		out.println("        movq $1, %rax");
		out.println("        syscall");
		out.println("        popq %rbp");
		out.println("        ret");
		out.println();
		out.println("print_string:");
		out.println("        pushq %rbp");
		out.println("        movq %rsp, %rbp");
		out.println("        movq $1, %rdi");
		out.println("        movq 16(%rbp), %rsi");
		out.println("        movq 24(%rbp), %rdx");
		out.println("        movq $1, %rax");
		out.println("        syscall");
		out.println("        popq %rbp");
		out.println("        ret");
	}

	/**
 	 * Generate code to evaluate the expression and
 	 * store the result in RAX.
 	 *
 	 * This must be implemented for every subclass of Expr!
 	 */
	// abstract public void Expr.genEval(PrintStream out);

	String IdDecl.address = "";
	// syn String IdDecl.address() = "-"+(index*8)+"(%rbp)";
	eq Program.getChild().lable() = "";
	eq Program.getChild().flable() = "";
	inh String Bool.lable();
	inh String Stat.flable();
	// eq Func.getChild().flable() = "asdasd";
	eq Func.getStats(int index).flable() = getID()+""+index;
	eq If.getStat(int index).flable() = flable()+""+index;
	eq If.getExpr().lable() = flable()+"else";
	eq While.getExpr().lable() = flable()+"end";
	//eq Block.getStmt(int index).lable() = ""+index;

	public void Func.genEval(PrintStream out)
	{
		out.println(getID()+":");
		out.println("        pushq %rbp");
		
		out.println("        movq %rsp, %rbp");
		

		for (int i = 0; i < getNumArgs(); ++i)
	    {	
	        ((IdDecl)getArgs(i)).address = "" + ((i+2)*8)+"(%rbp)";
	    }

		int j = 1;
	    for (int i = 0; i < getNumStats(); ++i)
	    {	
	    	if(getStats(i) instanceof IdDecl){
	    		((IdDecl)getStats(i)).address = "-"+(j*8)+"(%rbp)";
	    		j++;
	    	}
	        getStats(i).genEval(out);
	    }
	    out.println("        movq %rbp, %rsp");
		out.println("        popq %rbp");
		out.println("        ret");
	}
	public void Stat.genEval(PrintStream out)
	{
	    ;
	}
	public void While.genEval(PrintStream out)
	{
		out.println("while:");
		getExpr().genEval(out);
		for (int i = 0; i < getNumStat(); ++i) {
			getStat(i).genEval(out);
		}
		out.println("        jmp while");
	    out.println(flable()+"end:");
	}
	public void If.genEval(PrintStream out)
	{
		// out.println("        1 ");
		getExpr().genEval(out);
		// out.println("        2 ");

		for (int i = 0; i < getNumStat(); ++i) {

			getStat(i).genEval(out);
		}
		out.println("        jmp "+flable()+"fi");
		
		out.println(flable()+"else:");
		if (hasElse()) {
			getElse().genEval(out);
		}
	    out.println(flable()+"fi:");
	}
	public void Else.genEval(PrintStream out)
	{		
		for (int i = 0; i < getNumStat(); ++i) {
			getStat(i).genEval(out);
		}
	}
	public void Fcall.genEval(PrintStream out)
	{
		Func f = decl();

		// if(f.getID().equals("print")){
		// 	getExpr(0).genEval(out);
		// 	out.println("        call print");
		// 	return;
		// }
		// if(f.getID().equals("read")){
		// 	out.println("        call read");
		// 	return;
		// }

		for (int i = getNumExpr()-1; i >= 0; --i) {
			getExpr(i).genEval(out);
			out.println("        pushq %rax");
		}
		out.println("        call "+f.getID());
		out.println("        subq $" + (getNumExpr()*8) + ", %rsp");
	}
	public void Assi.genEval(PrintStream out)
	{
		getExpr().genEval(out);
	    out.println("        movq %rax, "+getIdUse().decl().address);
	}
	public void Num.genEval(PrintStream out)
	{
	    out.println("        movq $" + getNUM() + ", %rax");
	}
	public void Ret.genEval(PrintStream out)
	{
		getExpr().genEval(out);
		out.println("        movq %rbp, %rsp");
		out.println("        popq %rbp");
		out.println("        ret");
	}

	public void IdUse.genEval(PrintStream out) {
		out.println("        movq " + decl().address + ", %rax");
	}
	public void IdDecl.genEval(PrintStream out) {
		out.println("        pushq %rcx");
		if (hasExpr()) {
			getExpr().genEval(out);
		}
		out.println("        movq %rax, "+address);
	}
	public void EqExp.genEval(PrintStream out) {
		getLeft().genEval(out);
		out.println("        pushq %rax");
		getRight().genEval(out);
		out.println("        movq %rax, %rbx");
		out.println("        popq %rax");
		out.println("        cmpq %rbx, %rax");
		out.println("        jne "+lable());
	}
	public void NeExp.genEval(PrintStream out) {
		getLeft().genEval(out);
		out.println("        pushq %rax");
		getRight().genEval(out);
		out.println("        movq %rax, %rbx");
		out.println("        popq %rax");
		out.println("        cmpq %rbx, %rax");
		out.println("        je "+lable());
	}
	public void GtExp.genEval(PrintStream out) {
		getLeft().genEval(out);
		out.println("        pushq %rax");
		getRight().genEval(out);
		out.println("        movq %rax, %rbx");
		out.println("        popq %rax");
		out.println("        cmpq %rbx, %rax");
		out.println("        jle "+lable());
	}
	public void Add.genEval(PrintStream out) {
		getLeft().genEval(out);
		out.println("        pushq %rax");
		getRight().genEval(out);
		out.println("        movq %rax, %rbx");
		out.println("        popq %rax");
		out.println("        addq %rbx, %rax");
	}
	public void Sub.genEval(PrintStream out) {
		getLeft().genEval(out);
		out.println("        pushq %rax");
		getRight().genEval(out);
		out.println("        movq %rax, %rbx");
		out.println("        popq %rax");
		out.println("        subq %rbx, %rax");
	}

	public void Mul.genEval(PrintStream out) {
		getLeft().genEval(out);
		out.println("        pushq %rax");
		getRight().genEval(out);
		out.println("        movq %rax, %rbx");
		out.println("        popq %rax");
		out.println("        imulq %rbx, %rax");
	}

	public void Div.genEval(PrintStream out) {
		getLeft().genEval(out);
		out.println("        pushq %rax");
		getRight().genEval(out);
		out.println("        movq %rax, %rbx");
		out.println("        popq %rax");
		out.println("        movq $0, %rdx");// NB: clear RDX to prepare division RDX:RAX / RBX
		out.println("        idivq %rbx");
	}
	public void Mod.genEval(PrintStream out) {
		getLeft().genEval(out);
		out.println("        pushq %rax");
		getRight().genEval(out);
		out.println("        movq %rax, %rbx");
		out.println("        popq %rax");
		out.println("        movq $0, %rdx");// NB: clear RDX to prepare division RDX:RAX / RBX
		out.println("        idivq %rbx");
		out.println("        movq %rdx, %rax");
	}

}
