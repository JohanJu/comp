%class "LangParser";
%package "lang.ast";

%embed {:
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}
:};

%terminals ID, TYPE, LB, RB, LP, RP, NUM, ASSIGN, SEMI, ADD, SUB, MUL, DIV, MOD, CMP, COMMA, READ, PRINT, WHILE, IF, ELSE;

%typeof program = "Program";
%typeof funcList = "List";
%typeof func = "Func";
%typeof statList = "List";
%typeof stat = "Stat";
%typeof ifstat = "Stat";
%typeof elsestat = "Stat";
%typeof whilestat = "Stat";
%typeof idUse = "IdUse";
%typeof decl = "Decl";
%typeof factor = "Expr";
%typeof term = "Expr";
%typeof num = "Num";
%typeof assi = "Assi";
%typeof exp = "Expr";
%typeof cmpexp = "Expr";

%goal program;

program = funcList.a 							{: return new Program(a); :};

funcList =
		  func.a 								{: return new List().add(a); :}
		| funcList.a func.b 					{: return a.add(b); :}
		;

func = 
		TYPE ID.a LP RP LB statList.b RB 		{: return new Func(a,b); :}
		;

statList =
		  stat.a SEMI								{: return new List().add(a); :}
		| statList.a stat.b SEMI					{: return a.add(b); :}
		| //empty
		;

stat = 
		decl 
		| assi
		| ifstat 
		| whilestat  
		;
ifstat = 
		IF LP cmpexp.a RP LB statList.b RB					{: return new If(a,b,new Opt()); :} 
		| IF LP cmpexp.a RP LB statList.b RB elsestat.c		{: return new If(a,b,new Opt(c)); :}
		; 

elsestat = 
		ELSE LB statList.a RB					{: return new Else(a); :} 
		;

whilestat = 
		WHILE LP cmpexp.a RP LB statList.b RB 					{: return new While(a,b); :} 
		;

decl = 
		TYPE ID.a								{: return new Decl(a, new Opt());  :}
		| TYPE ID.a ASSIGN cmpexp.b  					{: return new Decl(a, new Opt(b)); :}
		;

assi = 
		ID.a ASSIGN cmpexp.b							{: return new Assi(a, b); :}
		;

cmpexp =
	exp 										
	| exp.a CMP.b exp.c							{:return new CmpExp(a, b, c); :}
	;

exp =
	term 										
	| exp.a ADD term.b 							{: return new Add(a, b); :}
	| exp.a SUB term.b 							{: return new Sub(a, b); :}
	;

factor =
	num
	| idUse
	| LP exp.a RP
	;
term =
	factor
	| term.a MUL factor.b 						{: return new Mul(a, b); :}
	| term.a DIV factor.b 						{: return new Div(a, b); :}
	| term.a MOD factor.b 						{: return new Mod(a, b); :}
	;

num = NUM.a 								{: return new Num(a); :} ;

idUse = ID.a									{: return new IdUse(a);  :} ;